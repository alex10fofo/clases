<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>POO ARCADE: Conceptos Fundamentales</title>
    <link rel="stylesheet" href="estilos.css">
</head>
<body>
    <header>
        <div class="monitor-border">
            <h1 class="glitch" data-text="POO ARCADE">POO ARCADE: Conceptos Fundamentales</h1>
            <p>PRESIONA START PARA NAVEGAR</p>
        </div>
    </header>

    <nav id="menu-navegacion">
        <a href="#clases" class="menu-item pulse-effect">1. CLASES & OBJETOS</a>
        <a href="#constructor" class="menu-item pulse-effect">2. CONSTRUCTORES</a>
        <a href="#encapsulacion" class="menu-item pulse-effect">3. ENCAPSULACI√ìN</a>
        <a href="#herencia" class="menu-item pulse-effect">4. HERENCIA</a>
        <a href="#polimorfismo" class="menu-item pulse-effect">5. POLIMORFISMO</a>
        <a href="#abstractas" class="menu-item pulse-effect">6. ABSTRACCI√ìN & INTERFACES</a>
        <a href="#relaciones" class="menu-item pulse-effect">7. RELACIONES ENTRE CLASES</a>
    </nav>

    <main>
        <section id="clases" class="topic-box">
            <h2 class="section-title">CLASES & OBJETOS <span class="retro-icon">üëæ</span></h2>
            <div class="content-detail">
                <h3>CLASE: EL BLUEPRINT</h3>
                <p>Una **Clase** es la **plantilla l√≥gica** o el esquema formal para la creaci√≥n de un objeto. No consume memoria en tiempo de ejecuci√≥n, es solo una definici√≥n. Define las caracter√≠sticas (**atributos**, variables) y los comportamientos (**m√©todos**, funciones) que todas las instancias de esa clase compartir√°n.</p>
                <p>En el mundo real, una clase ser√≠a el *plano* de un coche. No es el coche en s√≠, sino las instrucciones de c√≥mo construirlo.</p>

                <h3>OBJETO: LA INSTANCIA CONCRETA</h3>
                <p>Un **Objeto** es una **instancia concreta y tangible** de una clase. Cuando se crea un objeto, se reserva memoria para almacenar los valores espec√≠ficos de sus atributos. Cada objeto puede tener valores distintos para los mismos atributos definidos en la clase.</p>
                <p>Siguiendo la analog√≠a, un objeto es el *coche terminado* que se construye a partir del plano, con su propio color, VIN y velocidad actual.</p>
            </div>
            <div class="code-area">
                <h3>C√ìDIGO JAVA (<span class="code-label">PLANTILLA</span>)</h3>
                <pre>
public class ClaseAnimal {
    // Atributos
    public String nombre;
    public int edad;
    
    // Constructor
    public ClaseAnimal(String nombre, int edad) {
        this.nombre = nombre;
        this.edad = edad;
    }
    
    // M√©todo
    public void mostrarInfo() {
        System.out.println("El animal es: " + nombre + " y tiene " + edad + " a√±os.");
    }
    
    public static void main(String[] args) {
        // Creaci√≥n del objeto (instancia)
        ClaseAnimal perro = new ClaseAnimal("Fido", 5);
        
        System.out.println("--- PRUEBA CLASES Y CONSTRUCTORES ---");
        perro.mostrarInfo(); // Invocaci√≥n del m√©todo
    }
}
                </pre>
                <h3>CAPTURA DE PANTALLA (<span class="code-label">RUN</span>)</h3>
                <img src="./img/Captura de pantalla (263).png" alt="Captura de Clases y Objetos" class="uploaded-screenshot">
                <p class="code-description">Muestra la definici√≥n de una clase (ClaseAnimal) y la creaci√≥n y uso de un objeto (perro).</p>
            </div>
        </section>
        
        <section id="constructor" class="topic-box">
            <h2 class="section-title">CONSTRUCTORES <span class="retro-icon">üß±</span></h2>
            <div class="content-detail">
                <h3>FUNCI√ìN Y TIPOS</h3>
                <p>Un **Constructor** es un m√©todo especial que se llama autom√°ticamente en el momento de la **instanciaci√≥n** de un objeto. Su prop√≥sito principal es **inicializar el estado** (los atributos) del nuevo objeto. Si no defines uno, Java proporciona un constructor por defecto (sin argumentos).</p>
                <ul>
                    <li>**Constructor por Defecto (Default):** Sin par√°metros. Inicializa atributos con valores predeterminados (0, null, false).</li>
                    <li>**Constructor Parametrizado:** Acepta argumentos para inicializar los atributos con valores espec√≠ficos proporcionados por el programador.</li>
                </ul>
                <p>Los constructores llevan siempre el **mismo nombre que la clase** y no tienen tipo de retorno (ni siquiera `void`).</p>
            </div>
            <div class="code-area">
                <h3>C√ìDIGO JAVA (<span class="code-label">CONSTRUCTOR</span>)</h3>
                <pre>
public class EjemploConstructor {
    String mensaje;
    
    // Constructor parametrizado
    public EjemploConstructor(String texto) { 
        this.mensaje = texto; // Inicializa el atributo
        System.out.println("Constructor ejecutado: " + mensaje);
    }
    
    public static void main(String[] args) {
        // Al crear el objeto, se llama al constructor
        EjemploConstructor obj = new EjemploConstructor("Objeto inicializado al nacer.");
        // Output: Constructor ejecutado: Objeto inicializado al nacer.
    }
}
                </pre>
                <h3>CAPTURA DE PANTALLA (<span class="code-label">RUN</span>)</h3>
                <img src="./img/Captura de pantalla (261).png" alt="Captura de Constructores" class="uploaded-screenshot">
                <p class="code-description">El constructor nos permite inicializar los atributos de un objeto al momento de su creaci√≥n.</p>
            </div>
        </section>

        <section id="encapsulacion" class="topic-box">
            <h2 class="section-title">ENCAPSULACI√ìN <span class="retro-icon">üîí</span></h2>
            <div class="content-detail">
                <h3>SEGURIDAD Y CONTROL DE ACCESO</h3>
                <p>La **Encapsulaci√≥n** es el mecanismo que consiste en **agrupar los datos** (atributos) y el **c√≥digo que manipula esos datos** (m√©todos) en una √∫nica unidad (la clase). Su objetivo fundamental es **proteger los datos** de accesos o modificaciones no autorizadas o incorrectas.</p>
                <p>Se logra t√≠picamente en Java haciendo que los atributos sean **privados** (`private`) y proporcionando acceso controlado a trav√©s de m√©todos p√∫blicos llamados **Getters** (para leer el valor) y **Setters** (para modificar el valor, a menudo con validaciones).</p>
                <p>Esto asegura que la clase mantiene el control total sobre c√≥mo y cu√°ndo se modifican sus datos internos.</p>
            </div>
            <div class="code-area">
                <h3>C√ìDIGO JAVA (<span class="code-label">GETTERS/SETTERS</span>)</h3>
                <pre>
public class Encapsulacion {
    // Atributo privado, solo accesible desde esta clase
    private int saldoCuenta = 500;

    // Getter p√∫blico para leer el saldo
    public int getSaldoCuenta() {
        return saldoCuenta;
    }

    // Setter p√∫blico para depositar con validaci√≥n
    public void depositar(int cantidad) {
        if (cantidad > 0) {
            saldoCuenta += cantidad;
            System.out.println("Dep√≥sito exitoso. Nuevo saldo: " + saldoCuenta);
        } else {
            System.out.println("Error: La cantidad a depositar debe ser positiva.");
        }
    }
    
    public static void main(String[] args) {
        Encapsulacion miCaja = new Encapsulacion();
        
        System.out.println("--- PRUEBA ENCAPSULACI√ìN ---");
        System.out.println("Saldo inicial: " + miCaja.getSaldoCuenta()); // Acceso controlado
        
        miCaja.depositar(150); // Dep√≥sito v√°lido
        miCaja.depositar(-20); // Dep√≥sito inv√°lido, rechazado por la l√≥gica del setter
        // miCaja.saldoCuenta = 10000; // Esto no se puede hacer directamente porque saldoCuenta es private
    }
}
                </pre>
                <h3>CAPTURA DE PANTALLA (<span class="code-label">RUN</span>)</h3>
                <img src="./img/Captura de pantalla (265).png" alt="Captura de Encapsulaci√≥n" class="uploaded-screenshot">
                <p class="code-description">El atributo 'saldoCuenta' es privado y solo se modifica de forma segura a trav√©s del m√©todo 'depositar', que valida la entrada.</p>
            </div>
        </section>

        <section id="herencia" class="topic-box">
            <h2 class="section-title">HERENCIA <span class="retro-icon">üîó</span></h2>
            <div class="content-detail">
                <h3>RELACI√ìN "ES UN"</h3>
                <p>La **Herencia** permite crear una nueva clase (llamada **subclase**, clase hija o derivada) basada en una clase existente (llamada **superclase**, clase padre o base). La subclase hereda autom√°ticamente los atributos y m√©todos p√∫blicos y protegidos de su superclase, promoviendo la **reutilizaci√≥n de c√≥digo**.</p>
                <ul>
                    <li>**Clase Padre:** Define el comportamiento general.</li>
                    <li>**Clase Hija:** Define un comportamiento m√°s espec√≠fico y puede a√±adir o modificar la funcionalidad heredada.</li>
                </ul>
                <p>En Java, solo se permite la herencia **simple** entre clases (una clase solo puede tener una clase padre) y se utiliza la palabra clave `extends`.</p>
            </div>
            <div class="code-area">
                <h3>C√ìDIGO JAVA (<span class="code-label">EXTENDS</span>)</h3>
                <pre>
// Clase Padre (Superclase)
class Vehiculo {
    public void encenderMotor() {
        System.out.println("Motor encendido: El veh√≠culo est√° listo para partir.");
    }
    public void pararMotor() {
        System.out.println("Motor apagado: El veh√≠culo se ha detenido.");
    }
}

// Clase Hija (Subclase) que hereda de Vehiculo
class Coche extends Vehiculo { 
    public void acelerar() {
        System.out.println("El coche est√° acelerando a toda velocidad.");
    }
}

public class Herencia {
    public static void main(String[] args) {
        Coche miCoche = new Coche(); // Se crea un objeto Coche
        
        System.out.println("--- PRUEBA HERENCIA ---");
        miCoche.encenderMotor(); // M√©todo heredado de Vehiculo
        miCoche.acelerar();      // M√©todo propio de Coche
        miCoche.pararMotor();    // M√©todo heredado de Vehiculo
    }
}
                </pre>
                <h3>CAPTURA DE PANTALLA (<span class="code-label">RUN</span>)</h3>
                <img src="./img/Captura de pantalla (264).png" alt="Captura de Herencia" class="uploaded-screenshot">
                <p class="code-description">Muestra c√≥mo la clase 'Coche' hereda y utiliza los m√©todos 'encenderMotor' y 'pararMotor' de su superclase 'Vehiculo'.</p>
            </div>
        </section>

        <section id="polimorfismo" class="topic-box">
            <h2 class="section-title">POLIMORFISMO <span class="retro-icon">üîÆ</span></h2>
            <div class="content-detail">
                <h3>"MUCHAS FORMAS"</h3>
                <p>El **Polimorfismo** es la habilidad de que un mismo m√©todo o nombre pueda comportarse de forma diferente en diferentes contextos. Es un pilar esencial que permite manejar objetos de distintas clases de manera uniforme.</p>
                <ul>
                    <li>**Polimorfismo en Tiempo de Compilaci√≥n (Sobrecarga / Overloading):** Ocurre cuando m√∫ltiples m√©todos en la *misma clase* tienen el mismo nombre pero diferentes **par√°metros** (diferente n√∫mero o tipo de argumentos).</li>
                    <li>**Polimorfismo en Tiempo de Ejecuci√≥n (Sobrescritura / Overriding):** Ocurre cuando una subclase proporciona una implementaci√≥n espec√≠fica para un m√©todo que ya est√° definido en su superclase. Esto est√° directamente relacionado con la herencia.</li>
                </ul>
            </div>
            <div class="code-area">
                <h3>C√ìDIGO JAVA (<span class="code-label">SOBRECARGA/SOBRESCRITURA</span>)</h3>
                <pre>
// Clase base para sobrescritura
class Figura {
    public void dibujar() {
        System.out.println("Dibujando una figura gen√©rica.");
    }
}

// Clase derivada que sobrescribe el m√©todo dibujar
class Circulo extends Figura {
    @Override // Anotaci√≥n opcional, pero buena pr√°ctica
    public void dibujar() {
        System.out.println("Dibujando un C√≠rculo espec√≠fico.");
    }
}

// Clase para sobrecarga de m√©todos
class Calculadora {
    public int sumar(int a, int b) { // M√©todo sumar con dos enteros
        return a + b;
    }
    
    public double sumar(double a, double b) { // M√©todo sumar con dos doubles (sobrecarga)
        return a + b;
    }
    
    public int sumar(int a, int b, int c) { // M√©todo sumar con tres enteros (sobrecarga)
        return a + b + c;
    }
}

public class Polimorfismo {
    public static void main(String[] args) {
        System.out.println("--- PRUEBA POLIMORFISMO ---");

        // Sobrescritura (Overriding)
        Figura miFigura = new Figura();
        miFigura.dibujar(); // Output: Dibujando una figura gen√©rica.

        Circulo miCirculo = new Circulo();
        miCirculo.dibujar(); // Output: Dibujando un C√≠rculo espec√≠fico.

        // Demostraci√≥n de polimorfismo en tiempo de ejecuci√≥n
        Figura otraFigura = new Circulo(); // Referencia de tipo Figura, objeto de tipo Circulo
        otraFigura.dibujar(); // Output: Dibujando un C√≠rculo espec√≠fico. (Se invoca el m√©todo del objeto real)

        System.out.println("\n--- SOBRECARGA DE M√âTODOS ---");
        // Sobrecarga (Overloading)
        Calculadora calc = new Calculadora();
        System.out.println("Suma de 2 enteros: " + calc.sumar(5, 10));        // Llama a sumar(int, int)
        System.out.println("Suma de 2 doubles: " + calc.sumar(5.5, 10.5));    // Llama a sumar(double, double)
        System.out.println("Suma de 3 enteros: " + calc.sumar(1, 2, 3));      // Llama a sumar(int, int, int)
    }
}
                </pre>
                <h3>CAPTURA DE PANTALLA (<span class="code-label">RUN</span>)</h3>
                <img src="./img/Captura de pantalla (266).png" alt="Captura de Polimorfismo" class="uploaded-screenshot">
                <p class="code-description">Demuestra la sobrescritura de m√©todos (diferentes comportamientos para un mismo m√©todo en una jerarqu√≠a) y la sobrecarga (m√∫ltiples m√©todos con el mismo nombre pero diferentes par√°metros).</p>
            </div>
        </section>

        <section id="abstractas" class="topic-box">
            <h2 class="section-title">ABSTRACCI√ìN & INTERFACES <span class="retro-icon">‚öôÔ∏è</span></h2>
            <div class="content-detail">
                <h3>CLASES ABSTRACTAS</h3>
                <p>Una **Clase Abstracta** no puede ser instanciada directamente (no se pueden crear objetos de ella) y puede contener m√©todos abstractos (sin implementaci√≥n). Obliga a las clases hijas a proporcionar una implementaci√≥n concreta para esos m√©todos abstractos. Se declara con la palabra clave `abstract`.</p>
                <p>Son √∫tiles para definir una plantilla general o un contrato para un conjunto de clases relacionadas, donde algunas partes a√∫n no est√°n completamente definidas.</p>
                
                <h3>INTERFACES</h3>
                <p>Una **Interfaz** define un contrato completamente abstracto: solo contiene declaraciones de m√©todos (sin cuerpo) y constantes. Una clase que implementa (`implements`) una interfaz est√° obligada a proporcionar una implementaci√≥n para todos los m√©todos declarados en ella.</p>
                <p>A diferencia de las clases abstractas, una clase puede implementar m√∫ltiples interfaces, lo que permite lograr una forma de "herencia m√∫ltiple de comportamiento".</p>
            </div>
            <div class="code-area">
                <h3>C√ìDIGO JAVA (<span class="code-label">ABSTRACT/IMPLEMENTS</span>)</h3>
                <pre>
// Interfaz: Define un contrato de comportamiento
interface Dibujable {
    void dibujar(); // M√©todo abstracto por defecto en una interfaz
}

// Clase Abstracta: No se puede instanciar directamente, puede tener m√©todos abstractos y concretos
abstract class Forma {
    // M√©todo abstracto: debe ser implementado por las subclases concretas
    public abstract double calcularArea(); 
    
    // M√©todo concreto: tiene una implementaci√≥n por defecto
    public void mostrarMensaje() {
        System.out.println("Esta es una forma geom√©trica.");
    }
}

// Clase Concreta: Extiende la clase abstracta e implementa la interfaz
class Cuadrado extends Forma implements Dibujable {
    private double lado = 4.0;
    
    // Implementaci√≥n del m√©todo abstracto de Forma
    @Override
    public double calcularArea() {
        return lado * lado;
    }

    // Implementaci√≥n del m√©todo abstracto de Dibujable
    @Override
    public void dibujar() {
        System.out.println("Dibujando un cuadrado con lado " + lado);
    }
}

public class Abstraccion {
    public static void main(String[] args) {
        System.out.println("--- PRUEBA ABSTRACCI√ìN / INTERFACES ---");

        // No se puede instanciar directamente:
        // Forma miForma = new Forma(); // Esto dar√≠a un error de compilaci√≥n
        
        // Se instancia la clase concreta
        Cuadrado miCuadrado = new Cuadrado();
        
        // M√©todos heredados/implementados
        miCuadrado.mostrarMensaje();    // M√©todo concreto de la clase abstracta
        miCuadrado.dibujar();           // M√©todo implementado de la interfaz
        System.out.println("√Årea calculada: " + miCuadrado.calcularArea()); // M√©todo abstracto implementado
    }
}
                </pre>
                <h3>CAPTURA DE PANTALLA (<span class="code-label">RUN</span>)</h3>
                <img src="./img/Captura de pantalla (269).png" alt="Captura de Abstracci√≥n e Interfaces" class="uploaded-screenshot">
                <p class="code-description">Muestra c√≥mo la clase 'Cuadrado' implementa el contrato de 'Dibujable' y los m√©todos abstractos de 'Forma', demostrando la abstracci√≥n.</p>
            </div>
        </section>

        <section id="relaciones" class="topic-box">
            <h2 class="section-title glitch" data-text="RELACIONES ENTRE CLASES">RELACIONES ENTRE CLASES <span class="retro-icon">ü§ù</span></h2>
            
            <div class="content-detail">
                <p>En la programaci√≥n orientada a objetos (POO), estas relaciones definen c√≥mo las clases interact√∫an entre s√≠. Son cruciales en el dise√±o UML.</p>

                <h3>ASOCIACI√ìN (USA-UN)</h3>
                <p>Es la relaci√≥n m√°s general y menos estricta. Representa que dos clases **est√°n conectadas** y pueden comunicarse, pero no implica la relaci√≥n estricta de "todo-parte". Los objetos asociados existen **independientemente**.</p>
                <ul>
                    <li>**Ejemplo:** Un `Profesor` y un `Estudiante`. Ambos existen de forma independiente, pero est√°n relacionados a trav√©s de una asignatura o curso.</li>
                    <li>**S√≠mbolo UML:** Una simple **l√≠nea recta** entre las dos clases, a veces con flechas para indicar direcci√≥n o roles.</li>
                </ul>
                <div class="code-area">
                    <h3>C√ìDIGO JAVA (<span class="code-label">ASOCIACI√ìN</span>)</h3>
                    <pre>
class Profesor {
    public String nombre;
    
    public Profesor(String nombre) {
        this.nombre = nombre;
    }
    
    public void ense√±ar(String curso) {
        System.out.println(nombre + " est√° ense√±ando el curso: " + curso);
    }
}

class Estudiante {
    public String nombre;
    
    public Estudiante(String nombre) {
        this.nombre = nombre;
    }
    
    // Asociaci√≥n: Estudiante 'usa' o 'conoce' a un Profesor
    public void estudiarCon(Profesor p) { 
        System.out.println(nombre + " est√° tomando clases con el Profesor " + p.nombre + ".");
        p.ense√±ar("Programaci√≥n Avanzada"); // El estudiante interact√∫a con el profesor
    }
}

public class Asociacion {
    public static void main(String[] args) {
        Profesor prof = new Profesor("Dr. Garc√≠a");
        Estudiante est = new Estudiante("Ana");
        
        System.out.println("--- PRUEBA ASOCIACI√ìN ---");
        est.estudiarCon(prof); // El estudiante interact√∫a con el profesor
        
        // Ambos, profesor y estudiante, pueden existir de forma independiente
        Profesor otroProfesor = new Profesor("Mtra. Laura"); 
        // El Dr. Garc√≠a y Ana siguen existiendo, la Mtra. Laura es un objeto independiente
    }
}
                    </pre>
                    <h3>CAPTURA DE PANTALLA (<span class="code-label">RUN</span>)</h3>
                    <img src="./img/Captura de pantalla (267).png" alt="Captura de Asociaci√≥n" class="uploaded-screenshot">
                    <p class="code-description">Muestra c√≥mo un objeto 'Estudiante' interact√∫a con un objeto 'Profesor', que existen de forma separada y con su propio ciclo de vida.</p>
                </div>

                <h3>AGREGACI√ìN (HA-UN)</h3>
                <p>Es una forma de asociaci√≥n que representa una relaci√≥n de "**todo-parte**" donde las partes (los objetos agregados) pueden existir **independientemente** del todo (el objeto contenedor). Es una relaci√≥n **d√©bil**.</p>
                <ul>
                    <li>**Ejemplo:** Un `Coche` (Todo) y sus `Ruedas` (Parte). Si el coche se destruye, las ruedas siguen existiendo y pueden reutilizarse en otro coche.</li>
                    <li>**S√≠mbolo UML:** Una l√≠nea recta con un **rombo vac√≠o** en el lado del "Todo" (el objeto contenedor).</li>
                </ul>
                <div class="code-area">
                    <h3>C√ìDIGO JAVA (<span class="code-label">AGREGACI√ìN</span>)</h3>
                    <pre>
import java.util.ArrayList;
import java.util.List;

// Clase Parte (puede existir sola)
class Rueda {
    public String id;
    public Rueda(String id) {
        this.id = id;
        System.out.println("Rueda " + id + " fabricada.");
    }
}

// Clase Todo (contiene objetos Rueda)
class CocheAgregacion {
    private List&lt;Rueda&gt; ruedas; // Agregaci√≥n: El Coche "tiene" Ruedas
    public String modelo;
    
    public CocheAgregacion(String modelo) {
        this.modelo = modelo;
        this.ruedas = new ArrayList&lt;&gt;(); // Inicializa la lista de ruedas
        System.out.println("Coche modelo " + modelo + " ensamblado (sin ruedas a√∫n).");
    }
    
    // M√©todo para agregar ruedas que ya existen (inyecci√≥n externa)
    public void agregarRueda(Rueda r) {
        ruedas.add(r);
        System.out.println("Rueda " + r.id + " agregada al " + this.modelo + ".");
    }
    
    public void mostrarInfo() {
        System.out.println("\nEstado del Coche " + modelo + ": " + ruedas.size() + " ruedas.");
    }
}

public class Agregacion {
    public static void main(String[] args) {
        System.out.println("--- PRUEBA AGREGACI√ìN ---");

        // Las Ruedas existen independientemente del Coche
        Rueda r1 = new Rueda("RuedaDelanteraIzquierda");
        Rueda r2 = new Rueda("RuedaDelanteraDerecha"); 
        
        CocheAgregacion miCoche = new CocheAgregacion("Sedan Deportivo");
        miCoche.agregarRueda(r1); // Se agregan las ruedas al coche
        miCoche.agregarRueda(r2);
        
        miCoche.mostrarInfo();
        
        // Si 'miCoche' deja de existir, 'r1' y 'r2' seguir√≠an existiendo en memoria.
        // Se podr√≠an a√±adir a otro coche, por ejemplo.
        // CocheAgregacion otroCoche = new CocheAgregacion("Familiar");
        // otroCoche.agregarRueda(r1); // Reutilizando la rueda
    }
}
                    </pre>
                    <h3>CAPTURA DE PANTALLA (<span class="code-label">RUN</span>)</h3>
                    <img src="./img/Captura de pantalla (260).png" alt="Captura de Agregaci√≥n" class="uploaded-screenshot">
                    <p class="code-description">Muestra c√≥mo los objetos 'Rueda' se crean de forma independiente y luego se asocian a un objeto 'CocheAgregacion', destacando su existencia separada.</p>
                </div>

                <h3>COMPOSICI√ìN (PARTE-DE)</h3>
                <p>Es una forma de agregaci√≥n m√°s fuerte, donde las partes (los objetos compuestos) **no pueden existir sin el todo** (el objeto contenedor). Si el objeto contenedor se destruye, las partes tambi√©n se destruyen. Es una relaci√≥n **fuerte**.</p>
                <ul>
                    <li>**Ejemplo:** Una `Casa` (Todo) y sus `Habitaciones` (Parte). Si la casa se destruye, las habitaciones dejan de existir como tales. El ciclo de vida es el mismo.</li>
                    <li>**S√≠mbolo UML:** Una l√≠nea recta con un **rombo relleno** en el lado del "Todo" (el objeto contenedor).</li>
                </ul>
                <div class="code-area">
                    <h3>C√ìDIGO JAVA (<span class="code-label">COMPOSICI√ìN</span>)</h3>
                    <pre>
// Clase Parte (no puede existir sola)
class Motor {
    public String tipo;
    
    public Motor(String tipo) {
        this.tipo = tipo;
        System.out.println("Motor " + tipo + " creado internamente.");
    }
    
    public void arrancar() {
        System.out.println("El motor " + tipo + " ha arrancado.");
    }
}

// Clase Todo (compone un Motor)
class AutomovilComposicion {
    private Motor motor; // Composici√≥n: El Autom√≥vil "posee" y crea su Motor
    public String modelo;
    
    public AutomovilComposicion(String modelo, String tipoMotor) {
        this.modelo = modelo;
        // Composici√≥n: El motor nace con el autom√≥vil y su ciclo de vida est√° ligado a √©l
        this.motor = new Motor(tipoMotor); 
        System.out.println("Autom√≥vil modelo " + modelo + " fabricado con su motor.");
    }
    
    public void iniciar() {
        System.out.println("\nAutom√≥vil modelo " + modelo + " iniciando...");
        motor.arrancar();
    }
    
    // Al destruir el Automovil, el Motor tambi√©n ser√≠a destruido (en Java, por el GC)
}

public class Composicion {
    public static void main(String[] args) {
        System.out.println("--- PRUEBA COMPOSICI√ìN ---");

        AutomovilComposicion miAuto = new AutomovilComposicion("SUV Explorer", "V6 Turbo");
        miAuto.iniciar();
        
        // Si 'miAuto' se convierte en null (o sale de √°mbito), 
        // el objeto 'motor' al que hace referencia tambi√©n ser√° candidato a ser recolectado
        // por el recolector de basura, ya que no tiene vida independiente fuera del 'miAuto'.
    }
}
                    </pre>
                    <h3>CAPTURA DE PANTALLA (<span class="code-label">RUN</span>)</h3>
                    <img src="./img/Captura de pantalla (268).png" alt="Captura de Composici√≥n" class="uploaded-screenshot">
                    <p class="code-description">Muestra c√≥mo el objeto 'Motor' se crea directamente dentro del constructor de 'AutomovilComposicion', evidenciando que su existencia depende del 'AutomovilComposicion'.</p>
                </div>
            </div>
        </section>
        
    </main>
    
    <footer class="monitor-border">
        <p>MISSION COMPLETE | Gracias</p>
        <button onclick="cambiarFondo()">Modo Oscuro</button>
    </footer>

    <script src="script.js"></script>
</body>
</html>